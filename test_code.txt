# 1. Check and format user's inputs
# 2. Find all CONNECTED sub_graphs (test_graph_1.png)
# 3. Find all Cycles in a connected graph (test_graph_2.png)
# 4. Find the Shortest Path between two nodes (test_graph_2.png)




# 1. Check and format user's inputs

edges = ['Ab', 'ca', 'Cb']
edge_lens = [1, 2, 3, 2]
# Should return ValueError because edges and lens not one on one.
graph = Graph(edges, edge_lens)	

edges = ['Ab', 'ca', 'Cb', 'AC']
edge_lens = [1, 2, 3, 1]
# Should return ValueError "conflict lens input for edge AC"
graph = Graph(edges, edge_lens)	

edges = ['Ab', 'ca', 'Cb', 'AC']
edge_lens = [1, 2, 3, 2]
graph = Graph(edges, edge_lens)
graph.get_edges()	# Should return ['AB', 'AC', 'BC']
graph.get_edge_lens()	# Should return [1, 2, 3]




# 2. Find all CONNECTED sub_graphs (test_graph_1.png)

edges = ['AB', 'AC', 'BC', 'DE', 'EF', 'FG', 'DG']
edge_lens = [2, 2, 2, 1, 1, 1, 1]
graph.set_edges_and_lens(edges, edge_lens)
graph.get_connected_subgraphs()	# Should return two sets of sub_graphs




# 3. Find all Cycles in a connected graph (test_graph_2.png)

edges = ['AC', 'AD', 'BC', 'BD', 'BE', 'CE', 'EF', 'BF', 'AG']
edge_lens = [2, 2, 2, 2, 1, 2, 1, 1, 1]
graph.set_edges_and_lens(edges, edge_lens)
graph.get_cycles() # Should return a dictionary with key as the size of 
	       	   # cycle and value as a list of same-size cycles




# 4. Find the Shortest Path between two nodes (test_graph_2.png)
path_tuple = ("A", "F")
# Should return a list consisting all shortest paths, 
# and return the shortest length
graph.get_shortest_path(path_tuple)


edges = ["AC", "BC", "CD", "DF"]
edges = ["AC", "BC", "CD", "DF", "AG", "GH", "GI", "HJ"]
edge_lens = [1,2,3,4,5,6,7,8]

{2: ['H', 'D', 'B', 'G'], 1: ['F', 'C'], 3: ['E']}
{1: ['C', 'F'], 3: ['E'], 2: ['B', 'D', 'G', 'H']}
seq_dict = {0: ['A'], 1: ['C', 'F'], 2: ['G', 'H', 'B', 'D'], 3: ['E']}